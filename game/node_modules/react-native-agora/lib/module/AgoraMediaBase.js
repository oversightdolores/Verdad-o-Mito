function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
import './extension/AgoraMediaBaseExtension';
/**
 * The type of the audio route.
 */
export let AudioRoute;

/**
 * @ignore
 */
(function (AudioRoute) {
  AudioRoute[AudioRoute["RouteDefault"] = -1] = "RouteDefault";
  AudioRoute[AudioRoute["RouteHeadset"] = 0] = "RouteHeadset";
  AudioRoute[AudioRoute["RouteEarpiece"] = 1] = "RouteEarpiece";
  AudioRoute[AudioRoute["RouteHeadsetnomic"] = 2] = "RouteHeadsetnomic";
  AudioRoute[AudioRoute["RouteSpeakerphone"] = 3] = "RouteSpeakerphone";
  AudioRoute[AudioRoute["RouteLoudspeaker"] = 4] = "RouteLoudspeaker";
  AudioRoute[AudioRoute["RouteHeadsetbluetooth"] = 5] = "RouteHeadsetbluetooth";
  AudioRoute[AudioRoute["RouteUsb"] = 6] = "RouteUsb";
  AudioRoute[AudioRoute["RouteHdmi"] = 7] = "RouteHdmi";
  AudioRoute[AudioRoute["RouteDisplayport"] = 8] = "RouteDisplayport";
  AudioRoute[AudioRoute["RouteAirplay"] = 9] = "RouteAirplay";
})(AudioRoute || (AudioRoute = {}));
export let BytesPerSample;

/**
 * @ignore
 */
(function (BytesPerSample) {
  BytesPerSample[BytesPerSample["TwoBytesPerSample"] = 2] = "TwoBytesPerSample";
})(BytesPerSample || (BytesPerSample = {}));
export class AudioParameters {
  constructor() {
    _defineProperty(this, "sample_rate", void 0);
    _defineProperty(this, "channels", void 0);
    _defineProperty(this, "frames_per_buffer", void 0);
  }
}

/**
 * The use mode of the audio data.
 */
export let RawAudioFrameOpModeType;

/**
 * Media source type.
 */
(function (RawAudioFrameOpModeType) {
  RawAudioFrameOpModeType[RawAudioFrameOpModeType["RawAudioFrameOpModeReadOnly"] = 0] = "RawAudioFrameOpModeReadOnly";
  RawAudioFrameOpModeType[RawAudioFrameOpModeType["RawAudioFrameOpModeReadWrite"] = 2] = "RawAudioFrameOpModeReadWrite";
})(RawAudioFrameOpModeType || (RawAudioFrameOpModeType = {}));
export let MediaSourceType;

/**
 * @ignore
 */
(function (MediaSourceType) {
  MediaSourceType[MediaSourceType["AudioPlayoutSource"] = 0] = "AudioPlayoutSource";
  MediaSourceType[MediaSourceType["AudioRecordingSource"] = 1] = "AudioRecordingSource";
  MediaSourceType[MediaSourceType["PrimaryCameraSource"] = 2] = "PrimaryCameraSource";
  MediaSourceType[MediaSourceType["SecondaryCameraSource"] = 3] = "SecondaryCameraSource";
  MediaSourceType[MediaSourceType["PrimaryScreenSource"] = 4] = "PrimaryScreenSource";
  MediaSourceType[MediaSourceType["SecondaryScreenSource"] = 5] = "SecondaryScreenSource";
  MediaSourceType[MediaSourceType["CustomVideoSource"] = 6] = "CustomVideoSource";
  MediaSourceType[MediaSourceType["MediaPlayerSource"] = 7] = "MediaPlayerSource";
  MediaSourceType[MediaSourceType["RtcImagePngSource"] = 8] = "RtcImagePngSource";
  MediaSourceType[MediaSourceType["RtcImageJpegSource"] = 9] = "RtcImageJpegSource";
  MediaSourceType[MediaSourceType["RtcImageGifSource"] = 10] = "RtcImageGifSource";
  MediaSourceType[MediaSourceType["RemoteVideoSource"] = 11] = "RemoteVideoSource";
  MediaSourceType[MediaSourceType["TranscodedVideoSource"] = 12] = "TranscodedVideoSource";
  MediaSourceType[MediaSourceType["UnknownMediaSource"] = 100] = "UnknownMediaSource";
})(MediaSourceType || (MediaSourceType = {}));
export let ContentInspectResult;

/**
 * The type of video content moderation module.
 */
(function (ContentInspectResult) {
  ContentInspectResult[ContentInspectResult["ContentInspectNeutral"] = 1] = "ContentInspectNeutral";
  ContentInspectResult[ContentInspectResult["ContentInspectSexy"] = 2] = "ContentInspectSexy";
  ContentInspectResult[ContentInspectResult["ContentInspectPorn"] = 3] = "ContentInspectPorn";
})(ContentInspectResult || (ContentInspectResult = {}));
export let ContentInspectType;

/**
 * A structure used to configure the frequency of video screenshot and upload.ContentInspectModule
 */
(function (ContentInspectType) {
  ContentInspectType[ContentInspectType["ContentInspectInvalid"] = 0] = "ContentInspectInvalid";
  ContentInspectType[ContentInspectType["ContentInspectModeration"] = 1] = "ContentInspectModeration";
  ContentInspectType[ContentInspectType["ContentInspectSupervision"] = 2] = "ContentInspectSupervision";
})(ContentInspectType || (ContentInspectType = {}));
export class ContentInspectModule {
  constructor() {
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "interval", void 0);
  }
}

/**
 * Configuration of video screenshot and upload.
 */
export class ContentInspectConfig {
  constructor() {
    _defineProperty(this, "extraInfo", void 0);
    _defineProperty(this, "modules", void 0);
    _defineProperty(this, "moduleCount", void 0);
  }
}

/**
 * @ignore
 */
export class PacketOptions {
  constructor() {
    _defineProperty(this, "timestamp", void 0);
    _defineProperty(this, "audioLevelIndication", void 0);
  }
}

/**
 * @ignore
 */
export class AudioEncodedFrameInfo {
  constructor() {
    _defineProperty(this, "sendTs", void 0);
    _defineProperty(this, "codec", void 0);
  }
}

/**
 * The parameters of the audio frame in PCM format.
 */
export class AudioPcmFrame {
  constructor() {
    _defineProperty(this, "capture_timestamp", void 0);
    _defineProperty(this, "samples_per_channel_", void 0);
    _defineProperty(this, "sample_rate_hz_", void 0);
    _defineProperty(this, "num_channels_", void 0);
    _defineProperty(this, "bytes_per_sample", void 0);
    _defineProperty(this, "data_", void 0);
  }
}

/**
 * The channel mode.
 */
export let AudioDualMonoMode;

/**
 * The video pixel format.
 */
(function (AudioDualMonoMode) {
  AudioDualMonoMode[AudioDualMonoMode["AudioDualMonoStereo"] = 0] = "AudioDualMonoStereo";
  AudioDualMonoMode[AudioDualMonoMode["AudioDualMonoL"] = 1] = "AudioDualMonoL";
  AudioDualMonoMode[AudioDualMonoMode["AudioDualMonoR"] = 2] = "AudioDualMonoR";
  AudioDualMonoMode[AudioDualMonoMode["AudioDualMonoMix"] = 3] = "AudioDualMonoMix";
})(AudioDualMonoMode || (AudioDualMonoMode = {}));
export let VideoPixelFormat;

/**
 * Video display modes.
 */
(function (VideoPixelFormat) {
  VideoPixelFormat[VideoPixelFormat["VideoPixelDefault"] = 0] = "VideoPixelDefault";
  VideoPixelFormat[VideoPixelFormat["VideoPixelI420"] = 1] = "VideoPixelI420";
  VideoPixelFormat[VideoPixelFormat["VideoPixelBgra"] = 2] = "VideoPixelBgra";
  VideoPixelFormat[VideoPixelFormat["VideoPixelNv21"] = 3] = "VideoPixelNv21";
  VideoPixelFormat[VideoPixelFormat["VideoPixelRgba"] = 4] = "VideoPixelRgba";
  VideoPixelFormat[VideoPixelFormat["VideoPixelNv12"] = 8] = "VideoPixelNv12";
  VideoPixelFormat[VideoPixelFormat["VideoTexture2d"] = 10] = "VideoTexture2d";
  VideoPixelFormat[VideoPixelFormat["VideoTextureOes"] = 11] = "VideoTextureOes";
  VideoPixelFormat[VideoPixelFormat["VideoCvpixelNv12"] = 12] = "VideoCvpixelNv12";
  VideoPixelFormat[VideoPixelFormat["VideoCvpixelI420"] = 13] = "VideoCvpixelI420";
  VideoPixelFormat[VideoPixelFormat["VideoCvpixelBgra"] = 14] = "VideoCvpixelBgra";
  VideoPixelFormat[VideoPixelFormat["VideoPixelI422"] = 16] = "VideoPixelI422";
})(VideoPixelFormat || (VideoPixelFormat = {}));
export let RenderModeType;

/**
 * @ignore
 */
(function (RenderModeType) {
  RenderModeType[RenderModeType["RenderModeHidden"] = 1] = "RenderModeHidden";
  RenderModeType[RenderModeType["RenderModeFit"] = 2] = "RenderModeFit";
  RenderModeType[RenderModeType["RenderModeAdaptive"] = 3] = "RenderModeAdaptive";
})(RenderModeType || (RenderModeType = {}));
export let EglContextType;

/**
 * The video buffer type.
 */
(function (EglContextType) {
  EglContextType[EglContextType["EglContext10"] = 0] = "EglContext10";
  EglContextType[EglContextType["EglContext14"] = 1] = "EglContext14";
})(EglContextType || (EglContextType = {}));
export let VideoBufferType;

/**
 * The external video frame.
 */
(function (VideoBufferType) {
  VideoBufferType[VideoBufferType["VideoBufferRawData"] = 1] = "VideoBufferRawData";
  VideoBufferType[VideoBufferType["VideoBufferArray"] = 2] = "VideoBufferArray";
  VideoBufferType[VideoBufferType["VideoBufferTexture"] = 3] = "VideoBufferTexture";
})(VideoBufferType || (VideoBufferType = {}));
export class ExternalVideoFrame {
  constructor() {
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "format", void 0);
    _defineProperty(this, "buffer", void 0);
    _defineProperty(this, "stride", void 0);
    _defineProperty(this, "height", void 0);
    _defineProperty(this, "cropLeft", void 0);
    _defineProperty(this, "cropTop", void 0);
    _defineProperty(this, "cropRight", void 0);
    _defineProperty(this, "cropBottom", void 0);
    _defineProperty(this, "rotation", void 0);
    _defineProperty(this, "timestamp", void 0);
    _defineProperty(this, "eglType", void 0);
    _defineProperty(this, "textureId", void 0);
    _defineProperty(this, "matrix", void 0);
    _defineProperty(this, "metadata_buffer", void 0);
    _defineProperty(this, "metadata_size", void 0);
  }
}

/**
 * Configurations of the video frame.
 * The video data format is YUV420. Note that the buffer provides a pointer to a pointer. This interface cannot modify the pointer of the buffer, but it can modify the content of the buffer.
 */
export class VideoFrame {
  constructor() {
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "width", void 0);
    _defineProperty(this, "height", void 0);
    _defineProperty(this, "yStride", void 0);
    _defineProperty(this, "uStride", void 0);
    _defineProperty(this, "vStride", void 0);
    _defineProperty(this, "yBuffer", void 0);
    _defineProperty(this, "uBuffer", void 0);
    _defineProperty(this, "vBuffer", void 0);
    _defineProperty(this, "rotation", void 0);
    _defineProperty(this, "renderTimeMs", void 0);
    _defineProperty(this, "avsync_type", void 0);
    _defineProperty(this, "metadata_buffer", void 0);
    _defineProperty(this, "metadata_size", void 0);
    _defineProperty(this, "textureId", void 0);
    _defineProperty(this, "matrix", void 0);
    _defineProperty(this, "alphaBuffer", void 0);
  }
}

/**
 * @ignore
 */
export let MediaPlayerSourceType;

/**
 * The frame position of the video observer.
 */
(function (MediaPlayerSourceType) {
  MediaPlayerSourceType[MediaPlayerSourceType["MediaPlayerSourceDefault"] = 0] = "MediaPlayerSourceDefault";
  MediaPlayerSourceType[MediaPlayerSourceType["MediaPlayerSourceFullFeatured"] = 1] = "MediaPlayerSourceFullFeatured";
  MediaPlayerSourceType[MediaPlayerSourceType["MediaPlayerSourceSimple"] = 2] = "MediaPlayerSourceSimple";
})(MediaPlayerSourceType || (MediaPlayerSourceType = {}));
export let VideoModulePosition;

/**
 * Audio frame type.
 */
(function (VideoModulePosition) {
  VideoModulePosition[VideoModulePosition["PositionPostCapturer"] = 1] = "PositionPostCapturer";
  VideoModulePosition[VideoModulePosition["PositionPreRenderer"] = 2] = "PositionPreRenderer";
  VideoModulePosition[VideoModulePosition["PositionPreEncoder"] = 4] = "PositionPreEncoder";
})(VideoModulePosition || (VideoModulePosition = {}));
export let AudioFrameType;

/**
 * Raw audio data.
 */
(function (AudioFrameType) {
  AudioFrameType[AudioFrameType["FrameTypePcm16"] = 0] = "FrameTypePcm16";
})(AudioFrameType || (AudioFrameType = {}));
export class AudioFrame {
  constructor() {
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "samplesPerChannel", void 0);
    _defineProperty(this, "bytesPerSample", void 0);
    _defineProperty(this, "channels", void 0);
    _defineProperty(this, "samplesPerSec", void 0);
    _defineProperty(this, "buffer", void 0);
    _defineProperty(this, "renderTimeMs", void 0);
    _defineProperty(this, "avsync_type", void 0);
  }
}

/**
 * @ignore
 */
export let AudioFramePosition;

/**
 * Audio data format.
 * The SDK sets the audio data format in the following callbacks according to AudioParams. onRecordAudioFrame onPlaybackAudioFrame onMixedAudioFrame The SDK calculates the sampling interval through the samplesPerCall, sampleRate, and channel parameters in AudioParams, and triggers the onRecordAudioFrame, onPlaybackAudioFrame, onMixedAudioFrame, and onEarMonitoringAudioFrame callbacks according to the sampling interval.Sample interval (sec) = samplePerCall/(sampleRate × channel).Ensure that the sample interval ≥ 0.01 (s).
 */
(function (AudioFramePosition) {
  AudioFramePosition[AudioFramePosition["AudioFramePositionNone"] = 0] = "AudioFramePositionNone";
  AudioFramePosition[AudioFramePosition["AudioFramePositionPlayback"] = 1] = "AudioFramePositionPlayback";
  AudioFramePosition[AudioFramePosition["AudioFramePositionRecord"] = 2] = "AudioFramePositionRecord";
  AudioFramePosition[AudioFramePosition["AudioFramePositionMixed"] = 4] = "AudioFramePositionMixed";
  AudioFramePosition[AudioFramePosition["AudioFramePositionBeforeMixing"] = 8] = "AudioFramePositionBeforeMixing";
  AudioFramePosition[AudioFramePosition["AudioFramePositionEarMonitoring"] = 16] = "AudioFramePositionEarMonitoring";
})(AudioFramePosition || (AudioFramePosition = {}));
export class AudioParams {
  constructor() {
    _defineProperty(this, "sample_rate", void 0);
    _defineProperty(this, "channels", void 0);
    _defineProperty(this, "mode", void 0);
    _defineProperty(this, "samples_per_call", void 0);
  }
}

/**
 * The audio frame observer.
 */

/**
 * The audio spectrum data.
 */
export class AudioSpectrumData {
  constructor() {
    _defineProperty(this, "audioSpectrumData", void 0);
    _defineProperty(this, "dataLength", void 0);
  }
}

/**
 * Audio spectrum information of the remote user.
 */
export class UserAudioSpectrumInfo {
  constructor() {
    _defineProperty(this, "uid", void 0);
    _defineProperty(this, "spectrumData", void 0);
  }
}

/**
 * The audio spectrum observer.
 */

/**
 * The process mode of the video frame:
 */
export let VideoFrameProcessMode;

/**
 * The IVideoFrameObserver class.
 */
(function (VideoFrameProcessMode) {
  VideoFrameProcessMode[VideoFrameProcessMode["ProcessModeReadOnly"] = 0] = "ProcessModeReadOnly";
  VideoFrameProcessMode[VideoFrameProcessMode["ProcessModeReadWrite"] = 1] = "ProcessModeReadWrite";
})(VideoFrameProcessMode || (VideoFrameProcessMode = {}));
/**
 * The external video frame encoding type.
 */
export let ExternalVideoSourceType;

/**
 * The format of the recording file.
 */
(function (ExternalVideoSourceType) {
  ExternalVideoSourceType[ExternalVideoSourceType["VideoFrame"] = 0] = "VideoFrame";
  ExternalVideoSourceType[ExternalVideoSourceType["EncodedVideoFrame"] = 1] = "EncodedVideoFrame";
})(ExternalVideoSourceType || (ExternalVideoSourceType = {}));
export let MediaRecorderContainerFormat;

/**
 * The recording content.
 */
(function (MediaRecorderContainerFormat) {
  MediaRecorderContainerFormat[MediaRecorderContainerFormat["FormatMp4"] = 1] = "FormatMp4";
})(MediaRecorderContainerFormat || (MediaRecorderContainerFormat = {}));
export let MediaRecorderStreamType;

/**
 * The current recording state.
 */
(function (MediaRecorderStreamType) {
  MediaRecorderStreamType[MediaRecorderStreamType["StreamTypeAudio"] = 1] = "StreamTypeAudio";
  MediaRecorderStreamType[MediaRecorderStreamType["StreamTypeVideo"] = 2] = "StreamTypeVideo";
  MediaRecorderStreamType[MediaRecorderStreamType["StreamTypeBoth"] = 3] = "StreamTypeBoth";
})(MediaRecorderStreamType || (MediaRecorderStreamType = {}));
export let RecorderState;

/**
 * The reason for the state change.
 */
(function (RecorderState) {
  RecorderState[RecorderState["RecorderStateError"] = -1] = "RecorderStateError";
  RecorderState[RecorderState["RecorderStateStart"] = 2] = "RecorderStateStart";
  RecorderState[RecorderState["RecorderStateStop"] = 3] = "RecorderStateStop";
})(RecorderState || (RecorderState = {}));
export let RecorderErrorCode;

/**
 * Configurations for the local audio and video recording.
 */
(function (RecorderErrorCode) {
  RecorderErrorCode[RecorderErrorCode["RecorderErrorNone"] = 0] = "RecorderErrorNone";
  RecorderErrorCode[RecorderErrorCode["RecorderErrorWriteFailed"] = 1] = "RecorderErrorWriteFailed";
  RecorderErrorCode[RecorderErrorCode["RecorderErrorNoStream"] = 2] = "RecorderErrorNoStream";
  RecorderErrorCode[RecorderErrorCode["RecorderErrorOverMaxDuration"] = 3] = "RecorderErrorOverMaxDuration";
  RecorderErrorCode[RecorderErrorCode["RecorderErrorConfigChanged"] = 4] = "RecorderErrorConfigChanged";
})(RecorderErrorCode || (RecorderErrorCode = {}));
export class MediaRecorderConfiguration {
  constructor() {
    _defineProperty(this, "storagePath", void 0);
    _defineProperty(this, "containerFormat", void 0);
    _defineProperty(this, "streamType", void 0);
    _defineProperty(this, "maxDurationMs", void 0);
    _defineProperty(this, "recorderInfoUpdateInterval", void 0);
  }
}

/**
 * The information about the file that is recorded.
 */
export class RecorderInfo {
  constructor() {
    _defineProperty(this, "fileName", void 0);
    _defineProperty(this, "durationMs", void 0);
    _defineProperty(this, "fileSize", void 0);
  }
}

/**
 * The IMediaRecorderObserver class.
 */
//# sourceMappingURL=AgoraMediaBase.js.map