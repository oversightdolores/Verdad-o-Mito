function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import React from 'react';
import { findNodeHandle, requireNativeComponent, UIManager } from 'react-native';
import { TriggerableContext } from './TriggerableViewManager';
import { NativeAdsManager } from './NativeAdsManager';
import { createErrorFromErrorData, stripProperties } from '../utils';
import { LINKING_ERROR } from '../Constants';

/*
@property (nonatomic, copy) NSDictionary *targeting;

 */

const areSetsEqual = (a, b) => {
  if (a.size !== b.size) return false;
  for (const aItem of a) {
    if (!b.has(aItem)) return false;
  }
  return true;
};
const ComponentName = 'CTKAdManageNative';
const NativeAdView = UIManager.getViewManagerConfig(ComponentName) != null ? requireNativeComponent(ComponentName) : () => {
  // eslint-disable-next-line no-undef
  throw new Error(LINKING_ERROR);
};
export default (Component => class NativeAdWrapper extends React.Component {
  constructor(props) {
    super(props);
    _defineProperty(this, "clickableChildrenNodeHandles", new Map());
    _defineProperty(this, "registerClickableChild", child => {
      const handle = findNodeHandle(child);
      if (!handle) {
        return;
      }
      this.clickableChildrenNodeHandles.set(child, handle);
      this.setState({
        clickableChildren: this.state.clickableChildren.add(handle)
      });
    });
    _defineProperty(this, "unregisterClickableChild", child => {
      this.setState(_ref => {
        let {
          clickableChildren
        } = _ref;
        const newClickableChildren = new Set(clickableChildren);
        newClickableChildren.delete(this.clickableChildrenNodeHandles.get(child));
        this.clickableChildrenNodeHandles.delete(child);
        return {
          clickableChildren: newClickableChildren
        };
      });
    });
    _defineProperty(this, "handleSizeChange", _ref2 => {
      let {
        nativeEvent
      } = _ref2;
      const {
        height,
        width
      } = nativeEvent;
      this.setState({
        style: {
          width,
          height
        }
      });
      this.props.onSizeChange && this.props.onSizeChange(nativeEvent);
    });
    _defineProperty(this, "handleAdLoaded", _ref3 => {
      let {
        nativeEvent
      } = _ref3;
      this.setState({
        nativeAd: nativeEvent
      });
      this.props.onAdLoaded && this.props.onAdLoaded(nativeEvent);
    });
    this.state = {
      // iOS requires a non-null value
      clickableChildren: new Set(),
      style: {}
    };
  }
  componentDidMount() {
    this.reloadAd();
  }
  shouldComponentUpdate(nextProps, nextState) {
    if (Object.entries(this.state).toString() === Object.entries(nextState).toString() && Object.entries(this.props).toString() === Object.entries(nextProps).toString()) {
      return false;
    }
    return true;
  }
  componentDidUpdate(_, prevState) {
    const clickableChildrenChanged = areSetsEqual(prevState.clickableChildren, this.state.clickableChildren);
    if (clickableChildrenChanged) {
      const viewHandle = findNodeHandle(this);
      if (!viewHandle) {
        // Skip registration if the view is no longer valid.
        return;
      }
      NativeAdsManager.registerViewsForInteractionAsync(viewHandle, [...this.state.clickableChildren]).then(() => {
        // do nothing for now
      }).catch(() => {
        // do nothing for now
      });
    }
  }
  reloadAd() {
    UIManager.dispatchViewManagerCommand(findNodeHandle(this), UIManager.getViewManagerConfig(ComponentName).Commands.reloadAd, []);
  }
  renderAdComponent(componentProps) {
    if (!this.state.nativeAd) {
      return null;
    }
    return /*#__PURE__*/React.createElement(TriggerableContext.Provider, {
      value: {
        register: this.registerClickableChild,
        unregister: this.unregisterClickableChild
      }
    }, /*#__PURE__*/React.createElement(Component, _extends({}, componentProps, {
      nativeAd: this.state.nativeAd
    })));
  }
  render() {
    // Cast to any until https://github.com/Microsoft/TypeScript/issues/10727 is resolved
    const _a = this.props,
      {
        adsManager
      } = _a,
      rest = stripProperties(_a, ['adsManager', 'onAdLoaded']);
    return /*#__PURE__*/React.createElement(NativeAdView, {
      style: [this.props.style, this.state.style],
      adSize: this.props.adSize,
      loaderIndex: this.props.adLoaderIndex,
      correlator: this.props.correlator,
      customTemplateIds: this.props.customTemplateIds,
      validAdSizes: this.props.validAdSizes,
      validAdTypes: this.props.validAdTypes,
      onSizeChange: this.handleSizeChange,
      onAdLoaded: this.handleAdLoaded,
      onAdFailedToLoad: event => this.props.onAdFailedToLoad && this.props.onAdFailedToLoad(createErrorFromErrorData(event.nativeEvent.error)),
      onAppEvent: event => this.props.onAppEvent && this.props.onAppEvent(event.nativeEvent),
      onAdOpened: event => this.props.onAdOpened && this.props.onAdOpened(event.nativeEvent),
      onAdClosed: event => this.props.onAdClosed && this.props.onAdClosed(event.nativeEvent),
      onAdCustomClick: event => this.props.onAdCustomClick && this.props.onAdCustomClick(event.nativeEvent),
      targeting: this.props.targeting,
      customClickTemplateIds: this.props.customClickTemplateIds,
      adsManager: adsManager.toJSON()
    }, this.renderAdComponent(rest));
  }
});
//# sourceMappingURL=withNativeAd.js.map